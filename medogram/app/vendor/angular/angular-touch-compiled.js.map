{"version":3,"sources":["angular-touch.js"],"names":[],"mappings":"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","file":"angular-touch-compiled.js","sourcesContent":["/**\n * @license AngularJS v1.5.7\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* global ngTouchClickDirectiveFactory: false,\n */\n\n/**\n * @ngdoc module\n * @name ngTouch\n * @description\n *\n * # ngTouch\n *\n * The `ngTouch` module provides touch events and other helpers for touch-enabled devices.\n * The implementation is based on jQuery Mobile touch event handling\n * ([jquerymobile.com](http://jquerymobile.com/)).\n *\n *\n * See {@link ngTouch.$swipe `$swipe`} for usage.\n *\n * <div doc-module-components=\"ngTouch\"></div>\n *\n */\n\n// define ngTouch module\n/* global -ngTouch */\nvar ngTouch = angular.module('ngTouch', []);\n\nngTouch.provider('$touch', $TouchProvider);\n\nfunction nodeName_(element) {\n  return angular.lowercase(element.nodeName || (element[0] && element[0].nodeName));\n}\n\n/**\n * @ngdoc provider\n * @name $touchProvider\n *\n * @description\n * The `$touchProvider` allows enabling / disabling {@link ngTouch.ngClick ngTouch's ngClick directive}.\n */\n$TouchProvider.$inject = ['$provide', '$compileProvider'];\nfunction $TouchProvider($provide, $compileProvider) {\n\n  /**\n   * @ngdoc method\n   * @name  $touchProvider#ngClickOverrideEnabled\n   *\n   * @param {boolean=} enabled update the ngClickOverrideEnabled state if provided, otherwise just return the\n   * current ngClickOverrideEnabled state\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\n   *\n   * @kind function\n   *\n   * @description\n   * Call this method to enable/disable {@link ngTouch.ngClick ngTouch's ngClick directive}. If enabled,\n   * the default ngClick directive will be replaced by a version that eliminates the 300ms delay for\n   * click events on browser for touch-devices.\n   *\n   * The default is `false`.\n   *\n   */\n  var ngClickOverrideEnabled = false;\n  var ngClickDirectiveAdded = false;\n  this.ngClickOverrideEnabled = function(enabled) {\n    if (angular.isDefined(enabled)) {\n\n      if (enabled && !ngClickDirectiveAdded) {\n        ngClickDirectiveAdded = true;\n\n        // Use this to identify the correct directive in the delegate\n        ngTouchClickDirectiveFactory.$$moduleName = 'ngTouch';\n        $compileProvider.directive('ngClick', ngTouchClickDirectiveFactory);\n\n        $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {\n          if (ngClickOverrideEnabled) {\n            // drop the default ngClick directive\n            $delegate.shift();\n          } else {\n            // drop the ngTouch ngClick directive if the override has been re-disabled (because\n            // we cannot de-register added directives)\n            var i = $delegate.length - 1;\n            while (i >= 0) {\n              if ($delegate[i].$$moduleName === 'ngTouch') {\n                $delegate.splice(i, 1);\n                break;\n              }\n              i--;\n            }\n          }\n\n          return $delegate;\n        }]);\n      }\n\n      ngClickOverrideEnabled = enabled;\n      return this;\n    }\n\n    return ngClickOverrideEnabled;\n  };\n\n  /**\n  * @ngdoc service\n  * @name $touch\n  * @kind object\n  *\n  * @description\n  * Provides the {@link ngTouch.$touch#ngClickOverrideEnabled `ngClickOverrideEnabled`} method.\n  *\n  */\n  this.$get = function() {\n    return {\n      /**\n       * @ngdoc method\n       * @name  $touch#ngClickOverrideEnabled\n       *\n       * @returns {*} current value of `ngClickOverrideEnabled` set in the {@link ngTouch.$touchProvider $touchProvider},\n       * i.e. if {@link ngTouch.ngClick ngTouch's ngClick} directive is enabled.\n       *\n       * @kind function\n       */\n      ngClickOverrideEnabled: function() {\n        return ngClickOverrideEnabled;\n      }\n    };\n  };\n\n}\n\n/* global ngTouch: false */\n\n    /**\n     * @ngdoc service\n     * @name $swipe\n     *\n     * @description\n     * The `$swipe` service is a service that abstracts the messier details of hold-and-drag swipe\n     * behavior, to make implementing swipe-related directives more convenient.\n     *\n     * Requires the {@link ngTouch `ngTouch`} module to be installed.\n     *\n     * `$swipe` is used by the `ngSwipeLeft` and `ngSwipeRight` directives in `ngTouch`.\n     *\n     * # Usage\n     * The `$swipe` service is an object with a single method: `bind`. `bind` takes an element\n     * which is to be watched for swipes, and an object with four handler functions. See the\n     * documentation for `bind` below.\n     */\n\nngTouch.factory('$swipe', [function() {\n  // The total distance in any direction before we make the call on swipe vs. scroll.\n  var MOVE_BUFFER_RADIUS = 10;\n\n  var POINTER_EVENTS = {\n    'mouse': {\n      start: 'mousedown',\n      move: 'mousemove',\n      end: 'mouseup'\n    },\n    'touch': {\n      start: 'touchstart',\n      move: 'touchmove',\n      end: 'touchend',\n      cancel: 'touchcancel'\n    }\n  };\n\n  function getCoordinates(event) {\n    var originalEvent = event.originalEvent || event;\n    var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n    var e = (originalEvent.changedTouches && originalEvent.changedTouches[0]) || touches[0];\n\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n\n  function getEvents(pointerTypes, eventType) {\n    var res = [];\n    angular.forEach(pointerTypes, function(pointerType) {\n      var eventName = POINTER_EVENTS[pointerType][eventType];\n      if (eventName) {\n        res.push(eventName);\n      }\n    });\n    return res.join(' ');\n  }\n\n  return {\n    /**\n     * @ngdoc method\n     * @name $swipe#bind\n     *\n     * @description\n     * The main method of `$swipe`. It takes an element to be watched for swipe motions, and an\n     * object containing event handlers.\n     * The pointer types that should be used can be specified via the optional\n     * third argument, which is an array of strings `'mouse'` and `'touch'`. By default,\n     * `$swipe` will listen for `mouse` and `touch` events.\n     *\n     * The four events are `start`, `move`, `end`, and `cancel`. `start`, `move`, and `end`\n     * receive as a parameter a coordinates object of the form `{ x: 150, y: 310 }` and the raw\n     * `event`. `cancel` receives the raw `event` as its single parameter.\n     *\n     * `start` is called on either `mousedown` or `touchstart`. After this event, `$swipe` is\n     * watching for `touchmove` or `mousemove` events. These events are ignored until the total\n     * distance moved in either dimension exceeds a small threshold.\n     *\n     * Once this threshold is exceeded, either the horizontal or vertical delta is greater.\n     * - If the horizontal distance is greater, this is a swipe and `move` and `end` events follow.\n     * - If the vertical distance is greater, this is a scroll, and we let the browser take over.\n     *   A `cancel` event is sent.\n     *\n     * `move` is called on `mousemove` and `touchmove` after the above logic has determined that\n     * a swipe is in progress.\n     *\n     * `end` is called when a swipe is successfully completed with a `touchend` or `mouseup`.\n     *\n     * `cancel` is called either on a `touchcancel` from the browser, or when we begin scrolling\n     * as described above.\n     *\n     */\n    bind: function(element, eventHandlers, pointerTypes) {\n      // Absolute total movement, used to control swipe vs. scroll.\n      var totalX, totalY;\n      // Coordinates of the start position.\n      var startCoords;\n      // Last event's position.\n      var lastPos;\n      // Whether a swipe is active.\n      var active = false;\n\n      pointerTypes = pointerTypes || ['mouse', 'touch'];\n      element.on(getEvents(pointerTypes, 'start'), function(event) {\n        startCoords = getCoordinates(event);\n        active = true;\n        totalX = 0;\n        totalY = 0;\n        lastPos = startCoords;\n        eventHandlers['start'] && eventHandlers['start'](startCoords, event);\n      });\n      var events = getEvents(pointerTypes, 'cancel');\n      if (events) {\n        element.on(events, function(event) {\n          active = false;\n          eventHandlers['cancel'] && eventHandlers['cancel'](event);\n        });\n      }\n\n      element.on(getEvents(pointerTypes, 'move'), function(event) {\n        if (!active) return;\n\n        // Android will send a touchcancel if it thinks we're starting to scroll.\n        // So when the total distance (+ or - or both) exceeds 10px in either direction,\n        // we either:\n        // - On totalX > totalY, we send preventDefault() and treat this as a swipe.\n        // - On totalY > totalX, we let the browser handle it as a scroll.\n\n        if (!startCoords) return;\n        var coords = getCoordinates(event);\n\n        totalX += Math.abs(coords.x - lastPos.x);\n        totalY += Math.abs(coords.y - lastPos.y);\n\n        lastPos = coords;\n\n        if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {\n          return;\n        }\n\n        // One of totalX or totalY has exceeded the buffer, so decide on swipe vs. scroll.\n        if (totalY > totalX) {\n          // Allow native scrolling to take over.\n          active = false;\n          eventHandlers['cancel'] && eventHandlers['cancel'](event);\n          return;\n        } else {\n          // Prevent the browser from scrolling.\n          event.preventDefault();\n          eventHandlers['move'] && eventHandlers['move'](coords, event);\n        }\n      });\n\n      element.on(getEvents(pointerTypes, 'end'), function(event) {\n        if (!active) return;\n        active = false;\n        eventHandlers['end'] && eventHandlers['end'](getCoordinates(event), event);\n      });\n    }\n  };\n}]);\n\n/* global ngTouch: false,\n  nodeName_: false\n*/\n\n/**\n * @ngdoc directive\n * @name ngClick\n * @deprecated\n *\n * @description\n * <div class=\"alert alert-danger\">\n * **DEPRECATION NOTICE**: Beginning with Angular 1.5, this directive is deprecated and by default **disabled**.\n * The directive will receive no further support and might be removed from future releases.\n * If you need the directive, you can enable it with the {@link ngTouch.$touchProvider $touchProvider#ngClickOverrideEnabled}\n * function. We also recommend that you migrate to [FastClick](https://github.com/ftlabs/fastclick).\n * To learn more about the 300ms delay, this [Telerik article](http://developer.telerik.com/featured/300-ms-click-delay-ios-8/)\n * gives a good overview.\n * </div>\n * A more powerful replacement for the default ngClick designed to be used on touchscreen\n * devices. Most mobile browsers wait about 300ms after a tap-and-release before sending\n * the click event. This version handles them immediately, and then prevents the\n * following click event from propagating.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * This directive can fall back to using an ordinary click event, and so works on desktop\n * browsers as well as mobile.\n *\n * This directive also sets the CSS class `ng-click-active` while the element is being held\n * down (by a mouse click or touch) so you can restyle the depressed element if you wish.\n *\n * @element ANY\n * @param {expression} ngClick {@link guide/expression Expression} to evaluate\n * upon tap. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngClickExample\" deps=\"angular-touch.js\">\n      <file name=\"index.html\">\n        <button ng-click=\"count = count + 1\" ng-init=\"count=0\">\n          Increment\n        </button>\n        count: {{ count }}\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngClickExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\nvar ngTouchClickDirectiveFactory = ['$parse', '$timeout', '$rootElement',\n    function($parse, $timeout, $rootElement) {\n  var TAP_DURATION = 750; // Shorter than 750ms is a tap, longer is a taphold or drag.\n  var MOVE_TOLERANCE = 12; // 12px seems to work in most mobile browsers.\n  var PREVENT_DURATION = 2500; // 2.5 seconds maximum from preventGhostClick call to click\n  var CLICKBUSTER_THRESHOLD = 25; // 25 pixels in any dimension is the limit for busting clicks.\n\n  var ACTIVE_CLASS_NAME = 'ng-click-active';\n  var lastPreventedTime;\n  var touchCoordinates;\n  var lastLabelClickCoordinates;\n\n\n  // TAP EVENTS AND GHOST CLICKS\n  //\n  // Why tap events?\n  // Mobile browsers detect a tap, then wait a moment (usually ~300ms) to see if you're\n  // double-tapping, and then fire a click event.\n  //\n  // This delay sucks and makes mobile apps feel unresponsive.\n  // So we detect touchstart, touchcancel and touchend ourselves and determine when\n  // the user has tapped on something.\n  //\n  // What happens when the browser then generates a click event?\n  // The browser, of course, also detects the tap and fires a click after a delay. This results in\n  // tapping/clicking twice. We do \"clickbusting\" to prevent it.\n  //\n  // How does it work?\n  // We attach global touchstart and click handlers, that run during the capture (early) phase.\n  // So the sequence for a tap is:\n  // - global touchstart: Sets an \"allowable region\" at the point touched.\n  // - element's touchstart: Starts a touch\n  // (- touchcancel ends the touch, no click follows)\n  // - element's touchend: Determines if the tap is valid (didn't move too far away, didn't hold\n  //   too long) and fires the user's tap handler. The touchend also calls preventGhostClick().\n  // - preventGhostClick() removes the allowable region the global touchstart created.\n  // - The browser generates a click event.\n  // - The global click handler catches the click, and checks whether it was in an allowable region.\n  //     - If preventGhostClick was called, the region will have been removed, the click is busted.\n  //     - If the region is still there, the click proceeds normally. Therefore clicks on links and\n  //       other elements without ngTap on them work normally.\n  //\n  // This is an ugly, terrible hack!\n  // Yeah, tell me about it. The alternatives are using the slow click events, or making our users\n  // deal with the ghost clicks, so I consider this the least of evils. Fortunately Angular\n  // encapsulates this ugly logic away from the user.\n  //\n  // Why not just put click handlers on the element?\n  // We do that too, just to be sure. If the tap event caused the DOM to change,\n  // it is possible another element is now in that position. To take account for these possibly\n  // distinct elements, the handlers are global and care only about coordinates.\n\n  // Checks if the coordinates are close enough to be within the region.\n  function hit(x1, y1, x2, y2) {\n    return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;\n  }\n\n  // Checks a list of allowable regions against a click location.\n  // Returns true if the click should be allowed.\n  // Splices out the allowable region from the list after it has been used.\n  function checkAllowableRegions(touchCoordinates, x, y) {\n    for (var i = 0; i < touchCoordinates.length; i += 2) {\n      if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {\n        touchCoordinates.splice(i, i + 2);\n        return true; // allowable region\n      }\n    }\n    return false; // No allowable region; bust it.\n  }\n\n  // Global click handler that prevents the click if it's in a bustable zone and preventGhostClick\n  // was called recently.\n  function onClick(event) {\n    if (Date.now() - lastPreventedTime > PREVENT_DURATION) {\n      return; // Too old.\n    }\n\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    // Work around desktop Webkit quirk where clicking a label will fire two clicks (on the label\n    // and on the input element). Depending on the exact browser, this second click we don't want\n    // to bust has either (0,0), negative coordinates, or coordinates equal to triggering label\n    // click event\n    if (x < 1 && y < 1) {\n      return; // offscreen\n    }\n    if (lastLabelClickCoordinates &&\n        lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {\n      return; // input click triggered by label click\n    }\n    // reset label click coordinates on first subsequent click\n    if (lastLabelClickCoordinates) {\n      lastLabelClickCoordinates = null;\n    }\n    // remember label click coordinates to prevent click busting of trigger click event on input\n    if (nodeName_(event.target) === 'label') {\n      lastLabelClickCoordinates = [x, y];\n    }\n\n    // Look for an allowable region containing this click.\n    // If we find one, that means it was created by touchstart and not removed by\n    // preventGhostClick, so we don't bust it.\n    if (checkAllowableRegions(touchCoordinates, x, y)) {\n      return;\n    }\n\n    // If we didn't find an allowable region, bust the click.\n    event.stopPropagation();\n    event.preventDefault();\n\n    // Blur focused form elements\n    event.target && event.target.blur && event.target.blur();\n  }\n\n\n  // Global touchstart handler that creates an allowable region for a click event.\n  // This allowable region can be removed by preventGhostClick if we want to bust it.\n  function onTouchStart(event) {\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    touchCoordinates.push(x, y);\n\n    $timeout(function() {\n      // Remove the allowable region.\n      for (var i = 0; i < touchCoordinates.length; i += 2) {\n        if (touchCoordinates[i] == x && touchCoordinates[i + 1] == y) {\n          touchCoordinates.splice(i, i + 2);\n          return;\n        }\n      }\n    }, PREVENT_DURATION, false);\n  }\n\n  // On the first call, attaches some event handlers. Then whenever it gets called, it creates a\n  // zone around the touchstart where clicks will get busted.\n  function preventGhostClick(x, y) {\n    if (!touchCoordinates) {\n      $rootElement[0].addEventListener('click', onClick, true);\n      $rootElement[0].addEventListener('touchstart', onTouchStart, true);\n      touchCoordinates = [];\n    }\n\n    lastPreventedTime = Date.now();\n\n    checkAllowableRegions(touchCoordinates, x, y);\n  }\n\n  // Actual linking function.\n  return function(scope, element, attr) {\n    var clickHandler = $parse(attr.ngClick),\n        tapping = false,\n        tapElement,  // Used to blur the element after a tap.\n        startTime,   // Used to check if the tap was held too long.\n        touchStartX,\n        touchStartY;\n\n    function resetState() {\n      tapping = false;\n      element.removeClass(ACTIVE_CLASS_NAME);\n    }\n\n    element.on('touchstart', function(event) {\n      tapping = true;\n      tapElement = event.target ? event.target : event.srcElement; // IE uses srcElement.\n      // Hack for Safari, which can target text nodes instead of containers.\n      if (tapElement.nodeType == 3) {\n        tapElement = tapElement.parentNode;\n      }\n\n      element.addClass(ACTIVE_CLASS_NAME);\n\n      startTime = Date.now();\n\n      // Use jQuery originalEvent\n      var originalEvent = event.originalEvent || event;\n      var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n      var e = touches[0];\n      touchStartX = e.clientX;\n      touchStartY = e.clientY;\n    });\n\n    element.on('touchcancel', function(event) {\n      resetState();\n    });\n\n    element.on('touchend', function(event) {\n      var diff = Date.now() - startTime;\n\n      // Use jQuery originalEvent\n      var originalEvent = event.originalEvent || event;\n      var touches = (originalEvent.changedTouches && originalEvent.changedTouches.length) ?\n          originalEvent.changedTouches :\n          ((originalEvent.touches && originalEvent.touches.length) ? originalEvent.touches : [originalEvent]);\n      var e = touches[0];\n      var x = e.clientX;\n      var y = e.clientY;\n      var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));\n\n      if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {\n        // Call preventGhostClick so the clickbuster will catch the corresponding click.\n        preventGhostClick(x, y);\n\n        // Blur the focused element (the button, probably) before firing the callback.\n        // This doesn't work perfectly on Android Chrome, but seems to work elsewhere.\n        // I couldn't get anything to work reliably on Android Chrome.\n        if (tapElement) {\n          tapElement.blur();\n        }\n\n        if (!angular.isDefined(attr.disabled) || attr.disabled === false) {\n          element.triggerHandler('click', [event]);\n        }\n      }\n\n      resetState();\n    });\n\n    // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click\n    // something else nearby.\n    element.onclick = function(event) { };\n\n    // Actual click handler.\n    // There are three different kinds of clicks, only two of which reach this point.\n    // - On desktop browsers without touch events, their clicks will always come here.\n    // - On mobile browsers, the simulated \"fast\" click will call this.\n    // - But the browser's follow-up slow click will be \"busted\" before it reaches this handler.\n    // Therefore it's safe to use this directive on both mobile and desktop.\n    element.on('click', function(event, touchend) {\n      scope.$apply(function() {\n        clickHandler(scope, {$event: (touchend || event)});\n      });\n    });\n\n    element.on('mousedown', function(event) {\n      element.addClass(ACTIVE_CLASS_NAME);\n    });\n\n    element.on('mousemove mouseup', function(event) {\n      element.removeClass(ACTIVE_CLASS_NAME);\n    });\n\n  };\n}];\n\n/* global ngTouch: false */\n\n/**\n * @ngdoc directive\n * @name ngSwipeLeft\n *\n * @description\n * Specify custom behavior when an element is swiped to the left on a touchscreen device.\n * A leftward swipe is a quick, right-to-left slide of the finger.\n * Though ngSwipeLeft is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * To disable the mouse click and drag functionality, add `ng-swipe-disable-mouse` to\n * the `ng-swipe-left` or `ng-swipe-right` DOM Element.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeLeft {@link guide/expression Expression} to evaluate\n * upon left swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeLeftExample\" deps=\"angular-touch.js\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeLeftExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\n/**\n * @ngdoc directive\n * @name ngSwipeRight\n *\n * @description\n * Specify custom behavior when an element is swiped to the right on a touchscreen device.\n * A rightward swipe is a quick, left-to-right slide of the finger.\n * Though ngSwipeRight is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeRight {@link guide/expression Expression} to evaluate\n * upon right swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeRightExample\" deps=\"angular-touch.js\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeRightExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\nfunction makeSwipeDirective(directiveName, direction, eventName) {\n  ngTouch.directive(directiveName, ['$parse', '$swipe', function($parse, $swipe) {\n    // The maximum vertical delta for a swipe should be less than 75px.\n    var MAX_VERTICAL_DISTANCE = 75;\n    // Vertical distance should not be more than a fraction of the horizontal distance.\n    var MAX_VERTICAL_RATIO = 0.3;\n    // At least a 30px lateral motion is necessary for a swipe.\n    var MIN_HORIZONTAL_DISTANCE = 30;\n\n    return function(scope, element, attr) {\n      var swipeHandler = $parse(attr[directiveName]);\n\n      var startCoords, valid;\n\n      function validSwipe(coords) {\n        // Check that it's within the coordinates.\n        // Absolute vertical distance must be within tolerances.\n        // Horizontal distance, we take the current X - the starting X.\n        // This is negative for leftward swipes and positive for rightward swipes.\n        // After multiplying by the direction (-1 for left, +1 for right), legal swipes\n        // (ie. same direction as the directive wants) will have a positive delta and\n        // illegal ones a negative delta.\n        // Therefore this delta must be positive, and larger than the minimum.\n        if (!startCoords) return false;\n        var deltaY = Math.abs(coords.y - startCoords.y);\n        var deltaX = (coords.x - startCoords.x) * direction;\n        return valid && // Short circuit for already-invalidated swipes.\n            deltaY < MAX_VERTICAL_DISTANCE &&\n            deltaX > 0 &&\n            deltaX > MIN_HORIZONTAL_DISTANCE &&\n            deltaY / deltaX < MAX_VERTICAL_RATIO;\n      }\n\n      var pointerTypes = ['touch'];\n      if (!angular.isDefined(attr['ngSwipeDisableMouse'])) {\n        pointerTypes.push('mouse');\n      }\n      $swipe.bind(element, {\n        'start': function(coords, event) {\n          startCoords = coords;\n          valid = true;\n        },\n        'cancel': function(event) {\n          valid = false;\n        },\n        'end': function(coords, event) {\n          if (validSwipe(coords)) {\n            scope.$apply(function() {\n              element.triggerHandler(eventName);\n              swipeHandler(scope, {$event: event});\n            });\n          }\n        }\n      }, pointerTypes);\n    };\n  }]);\n}\n\n// Left is negative X-coordinate, right is positive.\nmakeSwipeDirective('ngSwipeLeft', -1, 'swipeleft');\nmakeSwipeDirective('ngSwipeRight', 1, 'swiperight');\n\n\n\n})(window, window.angular);\n"]}