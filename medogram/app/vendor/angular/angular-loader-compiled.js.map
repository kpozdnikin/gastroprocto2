{"version":3,"sources":["angular-loader.js"],"names":[],"mappings":"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","file":"angular-loader-compiled.js","sourcesContent":["/**\n * @license AngularJS v1.5.7\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n\n(function() {'use strict';\n    function isFunction(value) {return typeof value === 'function';};\n\n/* global toDebugString: true */\n\nfunction serializeObject(obj) {\n  var seen = [];\n\n  return JSON.stringify(obj, function(key, val) {\n    val = toJsonReplacer(key, val);\n    if (isObject(val)) {\n\n      if (seen.indexOf(val) >= 0) return '...';\n\n      seen.push(val);\n    }\n    return val;\n  });\n}\n\nfunction toDebugString(obj) {\n  if (typeof obj === 'function') {\n    return obj.toString().replace(/ \\{[\\s\\S]*$/, '');\n  } else if (isUndefined(obj)) {\n    return 'undefined';\n  } else if (typeof obj !== 'string') {\n    return serializeObject(obj);\n  }\n  return obj;\n}\n\n/**\n * @description\n *\n * This object provides a utility for producing rich Error messages within\n * Angular. It can be called as follows:\n *\n * var exampleMinErr = minErr('example');\n * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);\n *\n * The above creates an instance of minErr in the example namespace. The\n * resulting error will have a namespaced error code of example.one.  The\n * resulting error will replace {0} with the value of foo, and {1} with the\n * value of bar. The object is not restricted in the number of arguments it can\n * take.\n *\n * If fewer arguments are specified than necessary for interpolation, the extra\n * interpolation markers will be preserved in the final string.\n *\n * Since data will be parsed statically during a build step, some restrictions\n * are applied with respect to how minErr instances are created and called.\n * Instances should have names of the form namespaceMinErr for a minErr created\n * using minErr('namespace') . Error codes, namespaces and template strings\n * should all be static strings, not variables or general expressions.\n *\n * @param {string} module The namespace to use for the new minErr instance.\n * @param {function} ErrorConstructor Custom error constructor to be instantiated when returning\n *   error from returned function, for cases when a particular type of error is useful.\n * @returns {function(code:string, template:string, ...templateArgs): Error} minErr instance\n */\n\nfunction minErr(module, ErrorConstructor) {\n  ErrorConstructor = ErrorConstructor || Error;\n  return function() {\n    var SKIP_INDEXES = 2;\n\n    var templateArgs = arguments,\n      code = templateArgs[0],\n      message = '[' + (module ? module + ':' : '') + code + '] ',\n      template = templateArgs[1],\n      paramPrefix, i;\n\n    message += template.replace(/\\{\\d+\\}/g, function(match) {\n      var index = +match.slice(1, -1),\n        shiftedIndex = index + SKIP_INDEXES;\n\n      if (shiftedIndex < templateArgs.length) {\n        return toDebugString(templateArgs[shiftedIndex]);\n      }\n\n      return match;\n    });\n\n    message += '\\nhttp://errors.angularjs.org/1.5.7/' +\n      (module ? module + '/' : '') + code;\n\n    for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {\n      message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' +\n        encodeURIComponent(toDebugString(templateArgs[i]));\n    }\n\n    return new ErrorConstructor(message);\n  };\n}\n\n/**\n * @ngdoc type\n * @name angular.Module\n * @module ng\n * @description\n *\n * Interface for configuring angular {@link angular.module modules}.\n */\n\nfunction setupModuleLoader(window) {\n\n  var $injectorMinErr = minErr('$injector');\n  var ngMinErr = minErr('ng');\n\n  function ensure(obj, name, factory) {\n    return obj[name] || (obj[name] = factory());\n  }\n\n  var angular = ensure(window, 'angular', Object);\n\n  // We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap\n  angular.$$minErr = angular.$$minErr || minErr;\n\n  return ensure(angular, 'module', function() {\n    /** @type {Object.<string, angular.Module>} */\n    var modules = {};\n\n    /**\n     * @ngdoc function\n     * @name angular.module\n     * @module ng\n     * @description\n     *\n     * The `angular.module` is a global place for creating, registering and retrieving Angular\n     * modules.\n     * All modules (angular core or 3rd party) that should be available to an application must be\n     * registered using this mechanism.\n     *\n     * Passing one argument retrieves an existing {@link angular.Module},\n     * whereas passing more than one argument creates a new {@link angular.Module}\n     *\n     *\n     * # Module\n     *\n     * A module is a collection of services, directives, controllers, filters, and configuration information.\n     * `angular.module` is used to configure the {@link auto.$injector $injector}.\n     *\n     * ```js\n     * // Create a new module\n     * var myModule = angular.module('myModule', []);\n     *\n     * // register a new service\n     * myModule.value('appName', 'MyCoolApp');\n     *\n     * // configure existing services inside initialization blocks.\n     * myModule.config(['$locationProvider', function($locationProvider) {\n     *   // Configure existing providers\n     *   $locationProvider.hashPrefix('!');\n     * }]);\n     * ```\n     *\n     * Then you can create an injector and load your modules like this:\n     *\n     * ```js\n     * var injector = angular.injector(['ng', 'myModule'])\n     * ```\n     *\n     * However it's more likely that you'll just use\n     * {@link ng.directive:ngApp ngApp} or\n     * {@link angular.bootstrap} to simplify this process for you.\n     *\n     * @param {!string} name The name of the module to create or retrieve.\n     * @param {!Array.<string>=} requires If specified then new module is being created. If\n     *        unspecified then the module is being retrieved for further configuration.\n     * @param {Function=} configFn Optional configuration function for the module. Same as\n     *        {@link angular.Module#config Module#config()}.\n     * @returns {angular.Module} new module with the {@link angular.Module} api.\n     */\n    return function module(name, requires, configFn) {\n      var assertNotHasOwnProperty = function(name, context) {\n        if (name === 'hasOwnProperty') {\n          throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);\n        }\n      };\n\n      assertNotHasOwnProperty(name, 'module');\n      if (requires && modules.hasOwnProperty(name)) {\n        modules[name] = null;\n      }\n      return ensure(modules, name, function() {\n        if (!requires) {\n          throw $injectorMinErr('nomod', \"Module '{0}' is not available! You either misspelled \" +\n             \"the module name or forgot to load it. If registering a module ensure that you \" +\n             \"specify the dependencies as the second argument.\", name);\n        }\n\n        /** @type {!Array.<Array.<*>>} */\n        var invokeQueue = [];\n\n        /** @type {!Array.<Function>} */\n        var configBlocks = [];\n\n        /** @type {!Array.<Function>} */\n        var runBlocks = [];\n\n        var config = invokeLater('$injector', 'invoke', 'push', configBlocks);\n\n        /** @type {angular.Module} */\n        var moduleInstance = {\n          // Private state\n          _invokeQueue: invokeQueue,\n          _configBlocks: configBlocks,\n          _runBlocks: runBlocks,\n\n          /**\n           * @ngdoc property\n           * @name angular.Module#requires\n           * @module ng\n           *\n           * @description\n           * Holds the list of modules which the injector will load before the current module is\n           * loaded.\n           */\n          requires: requires,\n\n          /**\n           * @ngdoc property\n           * @name angular.Module#name\n           * @module ng\n           *\n           * @description\n           * Name of the module.\n           */\n          name: name,\n\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#provider\n           * @module ng\n           * @param {string} name service name\n           * @param {Function} providerType Construction function for creating new instance of the\n           *                                service.\n           * @description\n           * See {@link auto.$provide#provider $provide.provider()}.\n           */\n          provider: invokeLaterAndSetModuleName('$provide', 'provider'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#factory\n           * @module ng\n           * @param {string} name service name\n           * @param {Function} providerFunction Function for creating new instance of the service.\n           * @description\n           * See {@link auto.$provide#factory $provide.factory()}.\n           */\n          factory: invokeLaterAndSetModuleName('$provide', 'factory'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#service\n           * @module ng\n           * @param {string} name service name\n           * @param {Function} constructor A constructor function that will be instantiated.\n           * @description\n           * See {@link auto.$provide#service $provide.service()}.\n           */\n          service: invokeLaterAndSetModuleName('$provide', 'service'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#value\n           * @module ng\n           * @param {string} name service name\n           * @param {*} object Service instance object.\n           * @description\n           * See {@link auto.$provide#value $provide.value()}.\n           */\n          value: invokeLater('$provide', 'value'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#constant\n           * @module ng\n           * @param {string} name constant name\n           * @param {*} object Constant value.\n           * @description\n           * Because the constants are fixed, they get applied before other provide methods.\n           * See {@link auto.$provide#constant $provide.constant()}.\n           */\n          constant: invokeLater('$provide', 'constant', 'unshift'),\n\n           /**\n           * @ngdoc method\n           * @name angular.Module#decorator\n           * @module ng\n           * @param {string} name The name of the service to decorate.\n           * @param {Function} decorFn This function will be invoked when the service needs to be\n           *                           instantiated and should return the decorated service instance.\n           * @description\n           * See {@link auto.$provide#decorator $provide.decorator()}.\n           */\n          decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#animation\n           * @module ng\n           * @param {string} name animation name\n           * @param {Function} animationFactory Factory function for creating new instance of an\n           *                                    animation.\n           * @description\n           *\n           * **NOTE**: animations take effect only if the **ngAnimate** module is loaded.\n           *\n           *\n           * Defines an animation hook that can be later used with\n           * {@link $animate $animate} service and directives that use this service.\n           *\n           * ```js\n           * module.animation('.animation-name', function($inject1, $inject2) {\n           *   return {\n           *     eventName : function(element, done) {\n           *       //code to run the animation\n           *       //once complete, then run done()\n           *       return function cancellationFunction(element) {\n           *         //code to cancel the animation\n           *       }\n           *     }\n           *   }\n           * })\n           * ```\n           *\n           * See {@link ng.$animateProvider#register $animateProvider.register()} and\n           * {@link ngAnimate ngAnimate module} for more information.\n           */\n          animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#filter\n           * @module ng\n           * @param {string} name Filter name - this must be a valid angular expression identifier\n           * @param {Function} filterFactory Factory function for creating new instance of filter.\n           * @description\n           * See {@link ng.$filterProvider#register $filterProvider.register()}.\n           *\n           * <div class=\"alert alert-warning\">\n           * **Note:** Filter names must be valid angular {@link expression} identifiers, such as `uppercase` or `orderBy`.\n           * Names with special characters, such as hyphens and dots, are not allowed. If you wish to namespace\n           * your filters, then you can use capitalization (`myappSubsectionFilterx`) or underscores\n           * (`myapp_subsection_filterx`).\n           * </div>\n           */\n          filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#controller\n           * @module ng\n           * @param {string|Object} name Controller name, or an object map of controllers where the\n           *    keys are the names and the values are the constructors.\n           * @param {Function} constructor Controller constructor function.\n           * @description\n           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.\n           */\n          controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#directive\n           * @module ng\n           * @param {string|Object} name Directive name, or an object map of directives where the\n           *    keys are the names and the values are the factories.\n           * @param {Function} directiveFactory Factory function for creating new instance of\n           * directives.\n           * @description\n           * See {@link ng.$compileProvider#directive $compileProvider.directive()}.\n           */\n          directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#component\n           * @module ng\n           * @param {string} name Name of the component in camel-case (i.e. myComp which will match as my-comp)\n           * @param {Object} options Component definition object (a simplified\n           *    {@link ng.$compile#directive-definition-object directive definition object})\n           *\n           * @description\n           * See {@link ng.$compileProvider#component $compileProvider.component()}.\n           */\n          component: invokeLaterAndSetModuleName('$compileProvider', 'component'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#config\n           * @module ng\n           * @param {Function} configFn Execute this function on module load. Useful for service\n           *    configuration.\n           * @description\n           * Use this method to register work which needs to be performed on module loading.\n           * For more about how to configure services, see\n           * {@link providers#provider-recipe Provider Recipe}.\n           */\n          config: config,\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#run\n           * @module ng\n           * @param {Function} initializationFn Execute this function after injector creation.\n           *    Useful for application initialization.\n           * @description\n           * Use this method to register work which should be performed when the injector is done\n           * loading all modules.\n           */\n          run: function(block) {\n            runBlocks.push(block);\n            return this;\n          }\n        };\n\n        if (configFn) {\n          config(configFn);\n        }\n\n        return moduleInstance;\n\n        /**\n         * @param {string} provider\n         * @param {string} method\n         * @param {String=} insertMethod\n         * @returns {angular.Module}\n         */\n        function invokeLater(provider, method, insertMethod, queue) {\n          if (!queue) queue = invokeQueue;\n          return function() {\n            queue[insertMethod || 'push']([provider, method, arguments]);\n            return moduleInstance;\n          };\n        }\n\n        /**\n         * @param {string} provider\n         * @param {string} method\n         * @returns {angular.Module}\n         */\n        function invokeLaterAndSetModuleName(provider, method) {\n          return function(recipeName, factoryFunction) {\n            if (factoryFunction && isFunction(factoryFunction)) factoryFunction.$$moduleName = name;\n            invokeQueue.push([provider, method, arguments]);\n            return moduleInstance;\n          };\n        }\n      });\n    };\n  });\n\n}\n\nsetupModuleLoader(window);\n})(window);\n\n/**\n * Closure compiler type information\n *\n * @typedef { {\n *   requires: !Array.<string>,\n *   invokeQueue: !Array.<Array.<*>>,\n *\n *   service: function(string, Function):angular.Module,\n *   factory: function(string, Function):angular.Module,\n *   value: function(string, *):angular.Module,\n *\n *   filter: function(string, Function):angular.Module,\n *\n *   init: function(Function):angular.Module\n * } }\n */\nangular.Module;\n\n"]}